/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "backendmonitor_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace openstars { namespace base { namespace storage { namespace monitor {


cacheStat::~cacheStat() throw() {
}


void cacheStat::__set_cacheType(const std::string& val) {
  this->cacheType = val;
}

void cacheStat::__set_cacheMaxSize(const int64_t val) {
  this->cacheMaxSize = val;
}

void cacheStat::__set_cacheSize(const int64_t val) {
  this->cacheSize = val;
}

void cacheStat::__set_cacheHit(const int64_t val) {
  this->cacheHit = val;
}

void cacheStat::__set_cacheMiss(const int64_t val) {
  this->cacheMiss = val;
}

void cacheStat::__set_cacheMemSize(const int64_t val) {
  this->cacheMemSize = val;
}

uint32_t cacheStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cacheType);
          this->__isset.cacheType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cacheMaxSize);
          this->__isset.cacheMaxSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cacheSize);
          this->__isset.cacheSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cacheHit);
          this->__isset.cacheHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cacheMiss);
          this->__isset.cacheMiss = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cacheMemSize);
          this->__isset.cacheMemSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cacheStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cacheStat");

  xfer += oprot->writeFieldBegin("cacheType", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cacheType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheMaxSize", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cacheMaxSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheSize", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->cacheSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheHit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->cacheHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheMiss", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->cacheMiss);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheMemSize", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->cacheMemSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cacheStat &a, cacheStat &b) {
  using ::std::swap;
  swap(a.cacheType, b.cacheType);
  swap(a.cacheMaxSize, b.cacheMaxSize);
  swap(a.cacheSize, b.cacheSize);
  swap(a.cacheHit, b.cacheHit);
  swap(a.cacheMiss, b.cacheMiss);
  swap(a.cacheMemSize, b.cacheMemSize);
  swap(a.__isset, b.__isset);
}

cacheStat::cacheStat(const cacheStat& other0) {
  cacheType = other0.cacheType;
  cacheMaxSize = other0.cacheMaxSize;
  cacheSize = other0.cacheSize;
  cacheHit = other0.cacheHit;
  cacheMiss = other0.cacheMiss;
  cacheMemSize = other0.cacheMemSize;
  __isset = other0.__isset;
}
cacheStat& cacheStat::operator=(const cacheStat& other1) {
  cacheType = other1.cacheType;
  cacheMaxSize = other1.cacheMaxSize;
  cacheSize = other1.cacheSize;
  cacheHit = other1.cacheHit;
  cacheMiss = other1.cacheMiss;
  cacheMemSize = other1.cacheMemSize;
  __isset = other1.__isset;
  return *this;
}
void cacheStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cacheStat(";
  out << "cacheType=" << to_string(cacheType);
  out << ", " << "cacheMaxSize=" << to_string(cacheMaxSize);
  out << ", " << "cacheSize=" << to_string(cacheSize);
  out << ", " << "cacheHit=" << to_string(cacheHit);
  out << ", " << "cacheMiss=" << to_string(cacheMiss);
  out << ", " << "cacheMemSize=" << to_string(cacheMemSize);
  out << ")";
}


opStat::~opStat() throw() {
}


void opStat::__set_operationCount(const int64_t val) {
  this->operationCount = val;
}

void opStat::__set_cacheHit(const int64_t val) {
  this->cacheHit = val;
}

void opStat::__set_persistentHit(const int64_t val) {
  this->persistentHit = val;
}

void opStat::__set_excuteTime(const int64_t val) {
  this->excuteTime = val;
}

uint32_t opStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->operationCount);
          this->__isset.operationCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cacheHit);
          this->__isset.cacheHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->persistentHit);
          this->__isset.persistentHit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->excuteTime);
          this->__isset.excuteTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t opStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("opStat");

  xfer += oprot->writeFieldBegin("operationCount", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->operationCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheHit", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->cacheHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("persistentHit", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->persistentHit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("excuteTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->excuteTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(opStat &a, opStat &b) {
  using ::std::swap;
  swap(a.operationCount, b.operationCount);
  swap(a.cacheHit, b.cacheHit);
  swap(a.persistentHit, b.persistentHit);
  swap(a.excuteTime, b.excuteTime);
  swap(a.__isset, b.__isset);
}

opStat::opStat(const opStat& other2) {
  operationCount = other2.operationCount;
  cacheHit = other2.cacheHit;
  persistentHit = other2.persistentHit;
  excuteTime = other2.excuteTime;
  __isset = other2.__isset;
}
opStat& opStat::operator=(const opStat& other3) {
  operationCount = other3.operationCount;
  cacheHit = other3.cacheHit;
  persistentHit = other3.persistentHit;
  excuteTime = other3.excuteTime;
  __isset = other3.__isset;
  return *this;
}
void opStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "opStat(";
  out << "operationCount=" << to_string(operationCount);
  out << ", " << "cacheHit=" << to_string(cacheHit);
  out << ", " << "persistentHit=" << to_string(persistentHit);
  out << ", " << "excuteTime=" << to_string(excuteTime);
  out << ")";
}


storageStat::~storageStat() throw() {
}


void storageStat::__set_count(const int64_t val) {
  this->count = val;
}

void storageStat::__set_sizeKb(const int64_t val) {
  this->sizeKb = val;
}

void storageStat::__set_minSizeKb(const int64_t val) {
  this->minSizeKb = val;
}

uint32_t storageStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sizeKb);
          this->__isset.sizeKb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->minSizeKb);
          this->__isset.minSizeKb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t storageStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("storageStat");

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizeKb", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sizeKb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minSizeKb", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->minSizeKb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(storageStat &a, storageStat &b) {
  using ::std::swap;
  swap(a.count, b.count);
  swap(a.sizeKb, b.sizeKb);
  swap(a.minSizeKb, b.minSizeKb);
  swap(a.__isset, b.__isset);
}

storageStat::storageStat(const storageStat& other4) {
  count = other4.count;
  sizeKb = other4.sizeKb;
  minSizeKb = other4.minSizeKb;
  __isset = other4.__isset;
}
storageStat& storageStat::operator=(const storageStat& other5) {
  count = other5.count;
  sizeKb = other5.sizeKb;
  minSizeKb = other5.minSizeKb;
  __isset = other5.__isset;
  return *this;
}
void storageStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "storageStat(";
  out << "count=" << to_string(count);
  out << ", " << "sizeKb=" << to_string(sizeKb);
  out << ", " << "minSizeKb=" << to_string(minSizeKb);
  out << ")";
}


backendStat::~backendStat() throw() {
}


void backendStat::__set_cache(const cacheStat& val) {
  this->cache = val;
}

void backendStat::__set_savingQueueSize(const int64_t val) {
  this->savingQueueSize = val;
}

void backendStat::__set_warmingQueueSize(const int64_t val) {
  this->warmingQueueSize = val;
}

void backendStat::__set_readStat(const opStat& val) {
  this->readStat = val;
}

void backendStat::__set_writeStat(const opStat& val) {
  this->writeStat = val;
}

void backendStat::__set_writeStorage(const std::vector<std::string> & val) {
  this->writeStorage = val;
}

void backendStat::__set_readStorage(const std::vector<std::string> & val) {
  this->readStorage = val;
}

void backendStat::__set_processMemKb(const int64_t val) {
  this->processMemKb = val;
}

void backendStat::__set_processVirtKb(const int64_t val) {
  this->processVirtKb = val;
}

void backendStat::__set_storages(const std::map<std::string, storageStat> & val) {
  this->storages = val;
}

uint32_t backendStat::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cache.read(iprot);
          this->__isset.cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->savingQueueSize);
          this->__isset.savingQueueSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->warmingQueueSize);
          this->__isset.warmingQueueSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->readStat.read(iprot);
          this->__isset.readStat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->writeStat.read(iprot);
          this->__isset.writeStat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->writeStorage.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->writeStorage.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString(this->writeStorage[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.writeStorage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->readStorage.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->readStorage.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readString(this->readStorage[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.readStorage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->processMemKb);
          this->__isset.processMemKb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->processVirtKb);
          this->__isset.processVirtKb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->storages.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              std::string _key21;
              xfer += iprot->readString(_key21);
              storageStat& _val22 = this->storages[_key21];
              xfer += _val22.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.storages = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t backendStat::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("backendStat");

  xfer += oprot->writeFieldBegin("cache", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cache.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("savingQueueSize", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->savingQueueSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warmingQueueSize", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->warmingQueueSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readStat", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->readStat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeStat", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->writeStat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writeStorage", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->writeStorage.size()));
    std::vector<std::string> ::const_iterator _iter23;
    for (_iter23 = this->writeStorage.begin(); _iter23 != this->writeStorage.end(); ++_iter23)
    {
      xfer += oprot->writeString((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readStorage", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->readStorage.size()));
    std::vector<std::string> ::const_iterator _iter24;
    for (_iter24 = this->readStorage.begin(); _iter24 != this->readStorage.end(); ++_iter24)
    {
      xfer += oprot->writeString((*_iter24));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("processMemKb", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->processMemKb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("processVirtKb", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->processVirtKb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storages", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->storages.size()));
    std::map<std::string, storageStat> ::const_iterator _iter25;
    for (_iter25 = this->storages.begin(); _iter25 != this->storages.end(); ++_iter25)
    {
      xfer += oprot->writeString(_iter25->first);
      xfer += _iter25->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(backendStat &a, backendStat &b) {
  using ::std::swap;
  swap(a.cache, b.cache);
  swap(a.savingQueueSize, b.savingQueueSize);
  swap(a.warmingQueueSize, b.warmingQueueSize);
  swap(a.readStat, b.readStat);
  swap(a.writeStat, b.writeStat);
  swap(a.writeStorage, b.writeStorage);
  swap(a.readStorage, b.readStorage);
  swap(a.processMemKb, b.processMemKb);
  swap(a.processVirtKb, b.processVirtKb);
  swap(a.storages, b.storages);
  swap(a.__isset, b.__isset);
}

backendStat::backendStat(const backendStat& other26) {
  cache = other26.cache;
  savingQueueSize = other26.savingQueueSize;
  warmingQueueSize = other26.warmingQueueSize;
  readStat = other26.readStat;
  writeStat = other26.writeStat;
  writeStorage = other26.writeStorage;
  readStorage = other26.readStorage;
  processMemKb = other26.processMemKb;
  processVirtKb = other26.processVirtKb;
  storages = other26.storages;
  __isset = other26.__isset;
}
backendStat& backendStat::operator=(const backendStat& other27) {
  cache = other27.cache;
  savingQueueSize = other27.savingQueueSize;
  warmingQueueSize = other27.warmingQueueSize;
  readStat = other27.readStat;
  writeStat = other27.writeStat;
  writeStorage = other27.writeStorage;
  readStorage = other27.readStorage;
  processMemKb = other27.processMemKb;
  processVirtKb = other27.processVirtKb;
  storages = other27.storages;
  __isset = other27.__isset;
  return *this;
}
void backendStat::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "backendStat(";
  out << "cache=" << to_string(cache);
  out << ", " << "savingQueueSize=" << to_string(savingQueueSize);
  out << ", " << "warmingQueueSize=" << to_string(warmingQueueSize);
  out << ", " << "readStat=" << to_string(readStat);
  out << ", " << "writeStat=" << to_string(writeStat);
  out << ", " << "writeStorage=" << to_string(writeStorage);
  out << ", " << "readStorage=" << to_string(readStorage);
  out << ", " << "processMemKb=" << to_string(processMemKb);
  out << ", " << "processVirtKb=" << to_string(processVirtKb);
  out << ", " << "storages=" << to_string(storages);
  out << ")";
}

}}}} // namespace
